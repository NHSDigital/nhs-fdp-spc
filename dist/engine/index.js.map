{"version":3,"file":"index.js","sources":["../../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/retroOverlay.ts"],"sourcesContent":["import { ImprovementDirection, SpcRowV2, VariationIcon, Side } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport interface RetroOverlayOptions {\n\t// Currently we only support retro-colouring for confirmed shift runs.\n\t// Two-of-three and single >3σ are intentionally not backfilled to keep\n\t// alignment with NHSE SQL semantics for per-row eligibility.\n\tenableShift?: boolean;\n}\n\nfunction iconFor(side: Side, dir: ImprovementDirection): VariationIcon {\n\tif (dir === ImprovementDirection.Neither) {\n\t\treturn side === Side.Up ? VariationIcon.NeitherHigh : VariationIcon.NeitherLow;\n\t}\n\tif (dir === ImprovementDirection.Up) {\n\t\treturn side === Side.Up\n\t\t\t? VariationIcon.ImprovementHigh\n\t\t\t: VariationIcon.ConcernLow;\n\t}\n\t// dir === Down\n\treturn side === Side.Up\n\t\t? VariationIcon.ConcernHigh\n\t\t: VariationIcon.ImprovementLow;\n}\n\n/**\n * Compute a \"teaching view\" overlay that retro-colours pre-eligibility points\n * that sit on the same side of the mean as a later confirmed shift run.\n *\n * Notes and constraints (to preserve SQL parity):\n * - Engine rows remain unchanged; callers should only use these icons for\n *   visuals. The default engine `variationIcon` is still the source of truth\n *   for parity and testing.\n * - Only shift runs are backfilled; single-point and two-of-three are not\n *   retro-coloured.\n * - Backfill stops at the first eligible row in the partition; we never paint\n *   into rows where the engine would not have had limits yet.\n */\nexport function computeRetroShiftOverlay(\n\trows: SpcRowV2[],\n\tmetricImprovement: ImprovementDirection,\n\topts?: RetroOverlayOptions\n): Array<VariationIcon | null> {\n\tconst { enableShift = true } = opts ?? {};\n\tconst overlay: Array<VariationIcon | null> = Array(rows.length).fill(null);\n\tif (!enableShift) return overlay;\n\n\t// Group indices by partition\n\tconst byPart = new Map<number, number[]>();\n\trows.forEach((r, i) => {\n\t\tif (!byPart.has(r.partitionId)) byPart.set(r.partitionId, []);\n\t\tbyPart.get(r.partitionId)!.push(i);\n\t});\n\n\tfor (const [, idxs] of byPart) {\n\t\t// Identify the first eligible index in this partition\n\t\tconst firstEligibleIdx = idxs.find((i) => isNumber(rows[i].mean));\n\t\tif (firstEligibleIdx == null) continue;\n\n\t// Walk through eligible rows to find contiguous shift runs; for each run,\n\t// extend backwards across pre-eligibility rows that lie on the same side of\n\t// the mean at the run's start.\n\tlet runStart: number | null = null;\n\tlet runSide: Side | null = null;\n\n\tconst commitRun = (startIdx: number, side: Side) => {\n\t\t\t// Use the mean at startIdx as the reference; walk backwards to just before\n\t\t\t// the first eligible index, colouring points that lie on the same side.\n\t\t\tconst refMean = rows[startIdx].mean!;\n\t\t\tfor (let j = startIdx - 1; j >= idxs[0]; j--) {\n\t\t\t\tconst r = rows[j];\n\t\t\t\tif (r.ghost || !isNumber(r.value)) continue;\n\t\t\t\tif (j >= firstEligibleIdx) break; // never paint into eligible region\n\t\t\t\tconst sameSide = side === Side.Up ? r.value! > refMean : r.value! < refMean;\n\t\t\t\tif (!sameSide) break; // stop when side breaks\n\t\t\t\toverlay[j] = iconFor(side, metricImprovement);\n\t\t\t}\n\t\t};\n\n\t\tfor (const i of idxs) {\n\t\t\tconst r = rows[i];\n\t\t\tconst eligible = isNumber(r.mean);\n\t\t\tif (!eligible) {\n\t\t\t\t// only scan shift runs where engine was eligible\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst up = !!r.shiftUp;\n\t\t\tconst down = !!r.shiftDown;\n\t\t\tconst side: Side | null = up ? Side.Up : down ? Side.Down : null;\n\n\t\t\tif (side) {\n\t\t\t\t// If we are starting or continuing a run, manage state\n\t\t\t\tif (runStart == null) {\n\t\t\t\t\trunStart = i;\n\t\t\t\t\trunSide = side;\n\t\t\t\t} else if (runSide === side) {\n\t\t\t\t\t// continuing same-side run — nothing else to do yet\n\t\t\t\t} else {\n\t\t\t\t\t// side flipped — commit previous run and start new\n\t\t\t\t\tcommitRun(runStart, runSide!);\n\t\t\t\t\trunStart = i;\n\t\t\t\t\trunSide = side;\n\t\t\t\t}\n\t\t\t} else if (runStart != null) {\n\t\t\t\t// run ended; commit and reset\n\t\t\t\tcommitRun(runStart, runSide!);\n\t\t\t\trunStart = null;\n\t\t\t\trunSide = null;\n\t\t\t}\n\t\t}\n\n\t\t// Commit trailing run if still open\n\t\tif (runStart != null && runSide != null) commitRun(runStart, runSide);\n\t}\n\n\treturn overlay;\n}\n\nexport default { computeRetroShiftOverlay };\n"],"names":["iconFor","side","dir","ImprovementDirection","Side","VariationIcon","computeRetroShiftOverlay","rows","metricImprovement","opts","enableShift","overlay","byPart","r","i","idxs","firstEligibleIdx","isNumber","runStart","runSide","commitRun","startIdx","refMean","j","up","down"],"mappings":";;;;AAUA,SAASA,EAAQC,GAAYC,GAA0C;AACtE,SAAIA,MAAQC,EAAqB,UACzBF,MAASG,EAAK,KAAKC,EAAc,cAAcA,EAAc,aAEjEH,MAAQC,EAAqB,KACzBF,MAASG,EAAK,KAClBC,EAAc,kBACdA,EAAc,aAGXJ,MAASG,EAAK,KAClBC,EAAc,cACdA,EAAc;AAClB;AAeO,SAASC,EACfC,GACAC,GACAC,GAC8B;AAC9B,QAAM,EAAE,aAAAC,IAAc,GAAA,IAASD,KAAQ,CAAA,GACjCE,IAAuC,MAAMJ,EAAK,MAAM,EAAE,KAAK,IAAI;AACzE,MAAI,CAACG,EAAa,QAAOC;AAGzB,QAAMC,wBAAa,IAAA;AACnB,EAAAL,EAAK,QAAQ,CAACM,GAAGC,MAAM;AACtB,IAAKF,EAAO,IAAIC,EAAE,WAAW,KAAGD,EAAO,IAAIC,EAAE,aAAa,EAAE,GAC5DD,EAAO,IAAIC,EAAE,WAAW,EAAG,KAAKC,CAAC;AAAA,EAClC,CAAC;AAED,aAAW,CAAA,EAAGC,CAAI,KAAKH,GAAQ;AAE9B,UAAMI,IAAmBD,EAAK,KAAK,CAACD,MAAMG,EAASV,EAAKO,CAAC,EAAE,IAAI,CAAC;AAChE,QAAIE,KAAoB,KAAM;AAK/B,QAAIE,IAA0B,MAC1BC,IAAuB;AAE3B,UAAMC,IAAY,CAACC,GAAkBpB,MAAe;AAGlD,YAAMqB,IAAUf,EAAKc,CAAQ,EAAE;AAC/B,eAASE,IAAIF,IAAW,GAAGE,KAAKR,EAAK,CAAC,GAAGQ,KAAK;AAC7C,cAAMV,IAAIN,EAAKgB,CAAC;AAChB,YAAIV,EAAE,SAAS,CAACI,EAASJ,EAAE,KAAK,EAAG;AAGnC,YAFIU,KAAKP,KAEL,EADaf,MAASG,EAAK,KAAKS,EAAE,QAASS,IAAUT,EAAE,QAASS,GACrD;AACf,QAAAX,EAAQY,CAAC,IAAIvB,EAAQC,GAAMO,CAAiB;AAAA,MAC7C;AAAA,IACD;AAEA,eAAWM,KAAKC,GAAM;AACrB,YAAM,IAAIR,EAAKO,CAAC;AAEhB,UAAI,CADaG,EAAS,EAAE,IAAI;AAG/B;AAGD,YAAMO,IAAK,CAAC,CAAC,EAAE,SACTC,IAAO,CAAC,CAAC,EAAE,WACXxB,IAAoBuB,IAAKpB,EAAK,KAAKqB,IAAOrB,EAAK,OAAO;AAE5D,MAAIH,IAECiB,KAAY,QACfA,IAAWJ,GACXK,IAAUlB,KACAkB,MAAYlB,MAItBmB,EAAUF,GAAUC,CAAQ,GAC5BD,IAAWJ,GACXK,IAAUlB,KAEDiB,KAAY,SAEtBE,EAAUF,GAAUC,CAAQ,GAC5BD,IAAW,MACXC,IAAU;AAAA,IAEZ;AAGA,IAAID,KAAY,QAAQC,KAAW,QAAMC,EAAUF,GAAUC,CAAO;AAAA,EACrE;AAEA,SAAOR;AACR;"}