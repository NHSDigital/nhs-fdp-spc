{"version":3,"file":"presets-B0MKf-eZ.js","sources":["../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/constants.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/utils.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/limits.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/detector.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/conflict.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/trendSegments.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/visualCategories.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/postprocess/boundaryWindows.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/normaliser.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/engine.ts","../../../src/components/DataVisualisation/charts/SPC/SPCChart/logic_v2/presets.ts"],"sourcesContent":["import { SpcRuleId } from \"./types\";\n\n// Higher number = higher precedence (stronger rule).\n// Align exactly with SQL v2.6a conflict ranking used to compute PrimeDirection:\n// Trend (4) > Shift (3) > TwoSigma (2) > SinglePoint (1)\nexport const RULE_RANK_BY_ID: Record<SpcRuleId, number> = {\n\t[SpcRuleId.SinglePoint]: 1,\n\t[SpcRuleId.TwoSigma]: 2,\n\t[SpcRuleId.Shift]: 3,\n\t[SpcRuleId.Trend]: 4,\n};\n\n// XmR constants to mirror standard SPC formulas (SQL v2.6a parity)\n// d2 for n=2\nexport const D2 = 1.128 as const;\n// Moving range UCL factor\nexport const MR_UCL_FACTOR = 3.267 as const;\n// 3σ factor for XmR limits: mean ± 2.66 * MRbar\nexport const XMR_THREE_SIGMA_FACTOR = 2.66 as const;\n\n// T-chart transform exponent (SQL v2.6a): y = t^T_EXP, limits computed in y-space, then back-transformed\nexport const T_TRANSFORM_EXP = 0.2777 as const;\n","// A small helper to check a value is a proper finite number.\nimport { MR_UCL_FACTOR, XMR_THREE_SIGMA_FACTOR } from \"./constants\";\n\nexport function isNumber(n: unknown): n is number {\n\treturn typeof n === \"number\" && !Number.isNaN(n);\n}\n\n// Arithmetic mean of a numeric array. Returns 0 when empty to avoid NaN.\nexport function mean(nums: number[]): number {\n\treturn nums.reduce((a, b) => a + b, 0) / (nums.length || 1);\n}\n\n// Compute moving ranges against the previous non-ghosted numeric value, returning null when not applicable.\nexport function movingRanges(\n\tvalues: (number | null | undefined)[],\n\tghosts: boolean[]\n): (number | null)[] {\n\tconst mr: (number | null)[] = new Array(values.length).fill(null);\n\tlet lastIdx: number | null = null;\n\tfor (let i = 0; i < values.length; i++) {\n\t\tconst v = values[i];\n\t\tif (ghosts[i] || !isNumber(v)) continue;\n\t\tif (lastIdx !== null) {\n\t\t\tconst prev = values[lastIdx];\n\t\t\tif (isNumber(prev)) mr[i] = Math.abs(v - prev);\n\t\t}\n\t\tlastIdx = i;\n\t}\n\treturn mr;\n}\n\n// Compute MR mean with an optional single-pass exclusion of values above the UCL (3.267 * MRbar),\n// mirroring the SQL behaviour when moving range outlier removal is enabled.\nexport function mrMeanWithOptionalExclusion(\n\tmr: (number | null)[],\n\texcludeOutliers: boolean\n): { mrMean: number; mrUcl: number } {\n\tconst vals = mr.filter(isNumber) as number[];\n\tif (!vals.length) return { mrMean: NaN, mrUcl: NaN };\n\tlet arr = vals.slice();\n\tif (excludeOutliers) {\n\t\tconst meanMr = mean(arr);\n\t\tconst ucl = MR_UCL_FACTOR * meanMr; // standard MR UCL\n\t\tarr = arr.filter((v) => v <= ucl);\n\t}\n\tconst mrMean = mean(arr);\n\treturn { mrMean, mrUcl: MR_UCL_FACTOR * mrMean };\n}\n\n// Given a centre line and MR mean, return standard XmR limits and 1σ/2σ bands.\nexport function xmrLimits(center: number, mrMean: number) {\n\t// When mrMean is 0 (flat series), produce zero-width limits at the center line\n\t// instead of nulls so partitions with no variation still render control lines.\n\tif (!isNumber(center) || !isNumber(mrMean)) {\n\t\treturn {\n\t\t\tupperProcessLimit: null,\n\t\t\tlowerProcessLimit: null,\n\t\t\tupperTwoSigma: null,\n\t\t\tlowerTwoSigma: null,\n\t\t\tupperOneSigma: null,\n\t\t\tlowerOneSigma: null,\n\t\t};\n\t}\n\tconst threeSigma = XMR_THREE_SIGMA_FACTOR * mrMean;\n\tconst twoSigma = (2 / 3) * threeSigma;\n\tconst oneSigma = (1 / 3) * threeSigma;\n\treturn {\n\t\tupperProcessLimit: center + threeSigma,\n\t\tlowerProcessLimit: center - threeSigma,\n\t\tupperTwoSigma: center + twoSigma,\n\t\tlowerTwoSigma: center - twoSigma,\n\t\tupperOneSigma: center + oneSigma,\n\t\tlowerOneSigma: center - oneSigma,\n\t};\n}\n","import {\n\tisNumber,\n\tmean,\n\tmovingRanges,\n\tmrMeanWithOptionalExclusion,\n\txmrLimits,\n} from \"./utils\";\nimport { ChartType } from \"./types\";\nimport { T_TRANSFORM_EXP } from \"./constants\";\n\n// Compute control lines for a single partition based on chart type.\n// For v2.6a parity we focus on XmR here; T and G can be added later.\nexport function computePartitionLimits(\n\tchartType: ChartType,\n\tvalues: (number | null)[],\n\tghosts: boolean[],\n\texcludeMovingRangeOutliers: boolean\n) {\n\t// T chart: transform-positive values with exponent, compute XmR in y-space, back-transform control lines\n\tif (chartType === ChartType.T) {\n\t\tconst yVals: (number | null)[] = values.map((v) => (isNumber(v) && v! > 0 ? Math.pow(v!, T_TRANSFORM_EXP) : null));\n\t\tconst mr = movingRanges(yVals, ghosts);\n\t\tconst mrStats = mrMeanWithOptionalExclusion(mr, excludeMovingRangeOutliers);\n\t\t// Center: mean of eligible transformed values (exclude null/ghost)\n\t\tconst eligible = yVals.filter((v, i) => !ghosts[i] && isNumber(v)) as number[];\n\t\tconst centerY = eligible.length ? mean(eligible) : NaN;\n\t\tconst limY = xmrLimits(centerY, mrStats.mrMean);\n\t\t// Back-transform helper\n\t\tconst inv = (y: number | null) => (isNumber(y) && y! > 0 ? Math.pow(y!, 1 / T_TRANSFORM_EXP) : null);\n\t\tconst upl = isNumber(limY.upperProcessLimit) ? inv(limY.upperProcessLimit) : null;\n\t\tconst lpl = isNumber(limY.lowerProcessLimit) && limY.lowerProcessLimit > 0 ? inv(limY.lowerProcessLimit) : null; // suppress when Y-limit <= 0\n\t\tconst u2 = isNumber(limY.upperTwoSigma) ? inv(limY.upperTwoSigma) : null;\n\t\tconst l2 = isNumber(limY.lowerTwoSigma) && limY.lowerTwoSigma > 0 ? inv(limY.lowerTwoSigma) : null; // suppress when Y-limit <= 0\n\t\tconst u1 = isNumber(limY.upperOneSigma) ? inv(limY.upperOneSigma) : null;\n\t\tconst l1 = isNumber(limY.lowerOneSigma) && limY.lowerOneSigma > 0 ? inv(limY.lowerOneSigma) : null; // suppress when Y-limit <= 0\n\t\treturn {\n\t\t\tmean: isNumber(centerY) && centerY > 0 ? inv(centerY) : null,\n\t\t\tmr,\n\t\t\tmrMean: mrStats.mrMean,\n\t\t\tmrUcl: mrStats.mrUcl,\n\t\t\tupperProcessLimit: upl,\n\t\t\tlowerProcessLimit: lpl,\n\t\t\tupperTwoSigma: u2,\n\t\t\tlowerTwoSigma: l2,\n\t\t\tupperOneSigma: u1,\n\t\t\tlowerOneSigma: l1,\n\t\t};\n\t}\n\n\tif (chartType === ChartType.G) {\n\t\t// Geometric distribution based limits for count-between-events (support includes 0)\n\t\t// Compute sample mean m from eligible (non-ghost, numeric) counts\n\t\tconst eligible = values.filter((v, i) => !ghosts[i] && isNumber(v)) as number[];\n\t\tconst m = eligible.length ? mean(eligible) : NaN;\n\t\t// Convert mean to geometric parameter for 0-based support: mean = (1-p)/p => p = 1/(m+1)\n\t\tconst p = isNumber(m) ? 1 / (m + 1) : NaN;\n\t\t// Quantile function for 0-based geometric: Q(q) = ceil(log(1-q)/log(1-p)) - 1\n\t\tconst qgeom = (q: number) => {\n\t\t\tif (!isNumber(p) || p <= 0 || p >= 1) return NaN;\n\t\t\tconst k = Math.ceil(Math.log(1 - q) / Math.log(1 - p)) - 1;\n\t\t\treturn Math.max(0, k);\n\t\t};\n\t\t// Normal 3σ-equivalent tail ~ 0.00135\n\t\tconst qLower3 = 0.00135;\n\t\tconst qUpper3 = 1 - 0.00135;\n\t\t// 2σ-equivalent tails ~ 0.02275 / 0.97725\n\t\tconst qLower2 = 0.02275;\n\t\tconst qUpper2 = 1 - 0.02275;\n\t\t// 1σ-equivalent tails ~ 0.158655 / 0.841345\n\t\tconst qLower1 = 0.158655;\n\t\tconst qUpper1 = 1 - 0.158655;\n\n\t\tconst upl = qgeom(qUpper3);\n\t\tconst lpl = qgeom(qLower3); // already clamped to >= 0\n\t\tconst u2 = qgeom(qUpper2);\n\t\tconst l2 = qgeom(qLower2);\n\t\tconst u1 = qgeom(qUpper1);\n\t\tconst l1 = qgeom(qLower1);\n\n\t\treturn {\n\t\t\tmean: isNumber(m) ? m : null,\n\t\t\tmr: new Array(values.length).fill(null) as (number | null)[],\n\t\t\tmrMean: NaN,\n\t\t\tmrUcl: NaN,\n\t\t\tupperProcessLimit: isNumber(upl) ? upl : null,\n\t\t\tlowerProcessLimit: isNumber(lpl) ? lpl : null,\n\t\t\tupperTwoSigma: isNumber(u2) ? u2 : null,\n\t\t\tlowerTwoSigma: isNumber(l2) ? l2 : null,\n\t\t\tupperOneSigma: isNumber(u1) ? u1 : null,\n\t\t\tlowerOneSigma: isNumber(l1) ? l1 : null,\n\t\t};\n\t}\n\tif (chartType !== ChartType.XmR) {\n\t\t// Other types not implemented\n\t\treturn {\n\t\t\tmean: NaN,\n\t\t\tmr: new Array(values.length).fill(null) as (number | null)[],\n\t\t\tmrMean: NaN,\n\t\t\tmrUcl: NaN,\n\t\t\tupperProcessLimit: null as number | null,\n\t\t\tlowerProcessLimit: null as number | null,\n\t\t\tupperTwoSigma: null as number | null,\n\t\t\tlowerTwoSigma: null as number | null,\n\t\t\tupperOneSigma: null as number | null,\n\t\t\tlowerOneSigma: null as number | null,\n\t\t};\n\t}\n\n\tconst mr = movingRanges(values, ghosts);\n\t// Raw MR mean/UCL used for determining which value points are excluded from the centre-line\n\tconst mrVals = mr.filter(isNumber) as number[];\n\tconst rawMrMean = mrVals.length ? mean(mrVals) : NaN;\n\tconst rawMrUcl = isNumber(rawMrMean) ? 3.267 * rawMrMean : NaN;\n\n\t// Compute centre line: optionally exclude values whose MR exceeds the RAW MR UCL (include first valued point where MR is null)\n\tlet center: number = NaN;\n\t{\n\t\tconst eligibleVals = values.reduce<number[]>((acc, v, i) => {\n\t\t\t// Skip ghosts and non-numeric values\n\t\t\tif (ghosts[i] || !isNumber(v)) return acc;\n\t\t\t// If not excluding MR outliers, include directly\n\t\t\tif (!excludeMovingRangeOutliers) {\n\t\t\t\tacc.push(v as number);\n\t\t\t\treturn acc;\n\t\t\t}\n\t\t\t// Otherwise, include when MR is null (first eligible point) or MR <= raw UCL\n\t\t\tconst mri = mr[i];\n\t\t\tif (mri === null || !isNumber(rawMrUcl) || (isNumber(mri) && mri <= rawMrUcl)) {\n\t\t\t\tacc.push(v as number);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t\tcenter = eligibleVals.length ? mean(eligibleVals) : NaN;\n\t}\n\n\t// MR mean used for limits may itself exclude MR outliers (trim then recompute MRbar and UCL)\n\tconst tmp = mrMeanWithOptionalExclusion(mr, excludeMovingRangeOutliers);\n\tconst lim = xmrLimits(center, tmp.mrMean);\n\treturn {\n\t\tmean: center,\n\t\tmr,\n\t\tmrMean: tmp.mrMean,\n\t\tmrUcl: tmp.mrUcl,\n\t\t...lim,\n\t};\n}\n","import { SpcRowV2 } from \"./types\";\nimport { isNumber } from \"./utils\";\n\nexport interface DetectorConfig {\n\tshiftPoints: number;\n\ttrendPoints: number;\n\ttwoSigmaIncludeAboveThree?: boolean;\n\tenableFourOfFiveRule?: boolean;\n}\n\nexport function detectRulesInPartition(rows: SpcRowV2[], cfg: DetectorConfig) {\n\tconst idxs = rows\n\t\t.map((_, i) => i)\n\t\t.filter((i) => !rows[i].ghost && isNumber(rows[i].value));\n\tconst get = (i: number) => rows[i];\n\tconst shiftN = cfg.shiftPoints;\n\tconst trendN = cfg.trendPoints;\n\n\t// Shift\n\tlet runHigh: number[] = [];\n\tlet runLow: number[] = [];\n\tfor (const i of idxs) {\n\t\tconst r = get(i);\n\t\tif (!isNumber(r.mean) || !isNumber(r.value)) {\n\t\t\t// reset on ineligible rows and skip marking\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t} else if (r.value > r.mean) {\n\t\t\trunHigh.push(i);\n\t\t\trunLow = [];\n\t\t} else if (r.value < r.mean) {\n\t\t\trunLow.push(i);\n\t\t\trunHigh = [];\n\t\t} else {\n\t\t\t// equal to mean breaks both runs\n\t\t\trunHigh = [];\n\t\t\trunLow = [];\n\t\t}\n\t\tif (runHigh.length >= shiftN)\n\t\t\tfor (const j of runHigh) get(j).shiftUp = true;\n\t\tif (runLow.length >= shiftN)\n\t\t\tfor (const j of runLow) get(j).shiftDown = true;\n\t}\n\n\t// Two-of-three beyond 2σ (side-consistent)\n\tfor (let w = 0; w <= idxs.length - 3; w++) {\n\t\tconst win = idxs.slice(w, w + 3);\n\t\tconst trip = win.map(get);\n\t\tif (!trip.every((r) => isNumber(r.value) && isNumber(r.mean))) {\n\t\t\t// no marking when any value/mean missing\n\t\t\tcontinue;\n\t\t}\n\t\tconst mean = trip[0].mean!;\n\t\tconst allHigh = trip.every((r) => r.value! > mean);\n\t\tconst allLow = trip.every((r) => r.value! < mean);\n\t\tif (!allHigh && !allLow) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst u2 = trip[0].upperTwoSigma ?? Infinity;\n\t\tconst l2 = trip[0].lowerTwoSigma ?? -Infinity;\n\t\tconst u3 = trip[0].upperProcessLimit ?? Infinity;\n\t\tconst l3 = trip[0].lowerProcessLimit ?? -Infinity;\n\t\tconst highs = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! > u2 : (r.value! > u2 && r.value! <= u3));\n\t\tconst lows = trip.filter((r) => cfg.twoSigmaIncludeAboveThree ? r.value! < l2 : (r.value! < l2 && r.value! >= l3));\n\t\tif (allHigh && highs.length >= 2)\n\t\t\thighs.forEach((r) => (r.twoSigmaUp = true));\n\t\tif (allLow && lows.length >= 2)\n\t\t\tlows.forEach((r) => (r.twoSigmaDown = true));\n\t}\n\n\t// Four-of-five beyond 1σ (side-consistent, optional early-warning)\n\tif (cfg.enableFourOfFiveRule) {\n\t\tfor (let w = 0; w <= idxs.length - 5; w++) {\n\t\t\tconst win = idxs.slice(w, w + 5);\n\t\t\tconst quint = win.map(get);\n\t\t\tif (!quint.every((r) => isNumber(r.value) && isNumber(r.mean))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst mean = quint[0].mean!;\n\t\t\tconst allHigh = quint.every((r) => r.value! > mean);\n\t\t\tconst allLow = quint.every((r) => r.value! < mean);\n\t\t\tif (!allHigh && !allLow) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst u1 = quint[0].upperOneSigma ?? Infinity;\n\t\t\tconst l1 = quint[0].lowerOneSigma ?? -Infinity;\n\t\t\tconst highs = quint.filter((r) => r.value! > u1);\n\t\t\tconst lows = quint.filter((r) => r.value! < l1);\n\t\t\tif (allHigh && highs.length >= 4) highs.forEach((r) => (r.fourOfFiveUp = true));\n\t\t\tif (allLow && lows.length >= 4) lows.forEach((r) => (r.fourOfFiveDown = true));\n\t\t}\n\t}\n\n\t// Trend (strict monotonic inc/dec)\n\tfor (let w = 0; w <= idxs.length - trendN; w++) {\n\t\tconst win = idxs.slice(w, w + trendN);\n\t\tconst seq = win.map(get);\n\t\tif (!seq.every((r) => isNumber(r.value))) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet inc = true;\n\t\tlet dec = true;\n\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\tif (!inc && !dec) break;\n\t\t}\n\t\tif (inc) win.forEach((i) => (get(i).trendUp = true));\n\t\tif (dec) win.forEach((i) => (get(i).trendDown = true));\n\t}\n}\n","import {\n\tConflictStrategy,\n\tImprovementDirection,\n\tMetricConflictRule,\n\tPrimeDirection,\n\tSide,\n\tSpcRowV2,\n\tSpcRuleId,\n\tVariationIcon,\n} from \"./types\";\nimport { RULE_RANK_BY_ID } from \"./constants\";\n\n// Build per-side lists of active rules with numeric rank and compute the prime direction\n// by comparing the maximum rank on each side (Up vs Down), mirroring SQL's #ConflictRankingSummary.\nexport function getDirectionalSummary(row: SpcRowV2) {\n\tconst up: { id: SpcRuleId; rank: number }[] = [];\n\tconst dn: { id: SpcRuleId; rank: number }[] = [];\n\n\t// Single point and Two Sigma (separate one-sided flags)\n\tif (row.singlePointUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.singlePointDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.SinglePoint,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.SinglePoint],\n\t\t});\n\tif (row.twoSigmaUp)\n\t\tup.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\tif (row.twoSigmaDown)\n\t\tdn.push({\n\t\t\tid: SpcRuleId.TwoSigma,\n\t\t\trank: RULE_RANK_BY_ID[SpcRuleId.TwoSigma],\n\t\t});\n\t\n\t// Shift and Trend (no separate one-sided flags)\n\tif (row.shiftUp)\n\t\tup.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.shiftDown)\n\t\tdn.push({ id: SpcRuleId.Shift, rank: RULE_RANK_BY_ID[SpcRuleId.Shift] });\n\tif (row.trendUp)\n\t\tup.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\tif (row.trendDown)\n\t\tdn.push({ id: SpcRuleId.Trend, rank: RULE_RANK_BY_ID[SpcRuleId.Trend] });\n\n\t// Determine prime direction by comparing max rank on each side\n\tconst upMax = up.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst dnMax = dn.reduce((m, r) => Math.max(m, r.rank), 0);\n\tconst primeDirection =\n\t\tupMax > dnMax\n\t\t\t? PrimeDirection.Upwards\n\t\t\t: dnMax > upMax\n\t\t\t\t? PrimeDirection.Downwards\n\t\t\t\t: PrimeDirection.Same;\n\treturn { up, dn, upMax, dnMax, primeDirection };\n}\n\n// Decide whether aligned (improvement side) and opposite (concern side) candidates exist,\n// prior to any pruning. Mirrors SQL formation of SpecialCauseImprovementValue/ConcernValue.\nexport function deriveOriginalCandidates(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection\n) {\n\t// Aligned = high side for Up metrics; low side for Down metrics\n\tconst aligned =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointDown ||\n\t\t\t\t\trow.twoSigmaDown ||\n\t\t\t\t\trow.shiftDown ||\n\t\t\t\t\trow.trendDown\n\t\t\t\t: false;\n\t\n\t// Opposite = low side for Up metrics; high side for Down metrics\n\tconst opposite =\n\t\tmetric === ImprovementDirection.Up\n\t\t\t? row.singlePointDown ||\n\t\t\t\trow.twoSigmaDown ||\n\t\t\t\trow.shiftDown ||\n\t\t\t\trow.trendDown\n\t\t\t: metric === ImprovementDirection.Down\n\t\t\t\t? row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp\n\t\t\t\t: false;\n\t\n\treturn { aligned, opposite };\n}\n\n// Apply SQL-like pruning rules when both candidates exist, using primeDirection and metricConflictRule\n// to remove one side. Also sets variationIcon to match the remaining candidate(s) and records diagnostics.\n// Notes on global gating and precedence (see engine.ts):\n// - When settings.preferImprovementWhenConflict is true the engine disables favourable trend segmentation\n//   before conflict resolution. That gating happens in engine.ts and ensures improvement-first behaviour\n//   cannot be counteracted by segmentation creating opposite-side trend candidates.\n// - Within pruning, preferTrendWhenConflict is an optional early tie-break that, when enabled, keeps the\n//   side that contains a trend flag and drops the opposite side. It runs only when both candidates exist.\nexport function applySqlPruning(\n\trow: SpcRowV2,\n\tmetric: ImprovementDirection,\n\tmetricConflictRule: MetricConflictRule,\n\tpreferImprovementWhenConflict = false,\n\tconflictStrategy?: ConflictStrategy,\n\truleHierarchy?: SpcRuleId[],\n\tpreferTrendWhenConflict = false\n) {\n\t// Get directional summary (also sets row.primeDirection)\n\tconst { up, dn, upMax, dnMax, primeDirection } = getDirectionalSummary(row);\n\trow.primeDirection = primeDirection;\n\tconst originalImprovement = row.specialCauseImprovementValue;\n\tconst originalConcern = row.specialCauseConcernValue;\n\n\t// If both candidates exist, prune one side based on strategy\n\tif (\n\t\trow.specialCauseImprovementValue !== null &&\n\t\trow.specialCauseConcernValue !== null\n\t) {\n\t\tresolveConflict({ row, metric, metricConflictRule, preferImprovementWhenConflict, preferTrendWhenConflict, primeDirection, conflictStrategy, ruleHierarchy });\n\t}\n\n\t// Update variation icon to reflect pruned candidates\n\tif (metric === ImprovementDirection.Up) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementHigh\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernLow\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\n\t// Down metrics\n\t} else if (metric === ImprovementDirection.Down) {\n\t\trow.variationIcon =\n\t\t\trow.specialCauseImprovementValue !== null\n\t\t\t\t? VariationIcon.ImprovementLow\n\t\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t\t? VariationIcon.ConcernHigh\n\t\t\t\t\t: VariationIcon.CommonCause;\n\t\t\n\t// Neither metrics\n\t} else {\n\t\t// Neither not used in SQL conflict pruning branch\n\t\trow.variationIcon = VariationIcon.CommonCause;\n\t}\n\n\t// prime rank and winner rule id\n\tconst winningSide =\n\t\trow.specialCauseImprovementValue !== null\n\t\t\t? Side.Up\n\t\t\t: row.specialCauseConcernValue !== null\n\t\t\t\t? Side.Down\n\t\t\t\t: undefined;\n\tconst winningRank =\n\t\twinningSide === Side.Up\n\t\t\t? upMax\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dnMax\n\t\t\t\t: Math.max(upMax, dnMax);\n\trow.primeRank = winningRank || undefined;\n\tconst winner =\n\t\twinningSide === Side.Up\n\t\t\t? up.find((r) => r.rank === winningRank)\n\t\t\t: winningSide === Side.Down\n\t\t\t\t? dn.find((r) => r.rank === winningRank)\n\t\t\t\t: undefined;\n\trow.primeRuleId = winner?.id;\n\n\treturn { originalImprovement, originalConcern };\n}\n\n// General-purpose conflict resolver retaining SQL defaults but enabling alternative strategies.\n// When conflictStrategy is not supplied via settings, we infer it from preferImprovementWhenConflict flag\n// to preserve existing behaviour.\nexport function resolveConflict(args: {\n\trow: SpcRowV2;\n\tmetric: ImprovementDirection;\n\tmetricConflictRule: MetricConflictRule;\n\tpreferImprovementWhenConflict?: boolean;\n\tpreferTrendWhenConflict?: boolean;\n\tprimeDirection?: PrimeDirection;\n\tconflictStrategy?: ConflictStrategy;\n\truleHierarchy?: SpcRuleId[];\n}) {\n\tconst {\n\t\trow,\n\t\tmetric,\n\t\tmetricConflictRule,\n\t\tpreferImprovementWhenConflict,\n\t\tpreferTrendWhenConflict,\n\t\tprimeDirection = row.primeDirection ?? PrimeDirection.Same,\n\t\tconflictStrategy,\n\t\truleHierarchy,\n\t} = args;\n\t// Optional early override: when both candidates exist and a trend flag is present,\n\t// prefer the trend side over non-trend when requested. This runs before other strategies\n\t// to emulate story-specific expectations where a selected trend segment dominates.\n\tif (\n\t\tpreferTrendWhenConflict &&\n\t\trow.specialCauseImprovementValue !== null &&\n\t\trow.specialCauseConcernValue !== null\n\t) {\n\t\tconst upTrend = !!row.trendUp;\n\t\tconst downTrend = !!row.trendDown;\n\t\tif (metric === ImprovementDirection.Up) {\n\t\t\tif (upTrend && !downTrend) {\n\t\t\t\t// Keep improvement (high-side trend), drop concern\n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!upTrend && downTrend) {\n\t\t\t\t// Keep concern (low-side trend), drop improvement\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (metric === ImprovementDirection.Down) {\n\t\t\tif (downTrend && !upTrend) {\n\t\t\t\t// Keep improvement (low-side trend), drop concern (high)\n\t\t\t\trow.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!downTrend && upTrend) {\n\t\t\t\t// Keep concern (high-side trend), drop improvement\n\t\t\t\trow.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Prefer the explicit flag over strategy to mirror the intended Excel-like override.\n\t// If callers want a different behaviour, they should omit the flag and supply a strategy.\n\tconst strategy = preferImprovementWhenConflict\n\t\t? ConflictStrategy.PreferImprovement\n\t\t: conflictStrategy ?? ConflictStrategy.SqlPrimeThenRule;\n\n\tif (strategy === ConflictStrategy.PreferImprovement) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null;\n\t\telse if (metric === ImprovementDirection.Down) row.specialCauseImprovementValue = null;\n\t\treturn;\n\t}\n\n\tif (strategy === ConflictStrategy.RuleHierarchy) {\n\t\t// Determine which side contains the highest-precedence rule given an order (defaults to SQL rank)\n\t\tconst order: SpcRuleId[] = ruleHierarchy ?? [SpcRuleId.Trend, SpcRuleId.Shift, SpcRuleId.TwoSigma, SpcRuleId.SinglePoint];\n\t\tconst { up, dn } = getDirectionalSummary(row);\n\t\t// Find first rule in order that appears on either side\n\t\tfor (const rid of order) {\n\t\t\tconst upHas = up.some((r) => r.id === rid);\n\t\t\tconst dnHas = dn.some((r) => r.id === rid);\n\t\t\tif (upHas && !dnHas) {\n\t\t\t\t// keep Up side for Up metrics (improvement) else prune accordingly\n\t\t\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (dnHas && !upHas) {\n\t\t\t\tif (metric === ImprovementDirection.Up) row.specialCauseImprovementValue = null; else row.specialCauseConcernValue = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (upHas && dnHas) {\n\t\t\t\t// Both sides contain same highest rule: fall back to MetricConflictRule\n\t\t\t\tif (metric === ImprovementDirection.Up) {\n\t\t\t\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\t} else if (metric === ImprovementDirection.Down) {\n\t\t\t\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// If nothing matched, default to SQL behaviour\n\t}\n\n\t// Default (SQL parity): PrimeDirection first, then MetricConflictRule only when Same\n\tif (primeDirection === PrimeDirection.Upwards) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseConcernValue = null; else if (metric === ImprovementDirection.Down) row.specialCauseImprovementValue = null;\n\t} else if (primeDirection === PrimeDirection.Downwards) {\n\t\tif (metric === ImprovementDirection.Up) row.specialCauseImprovementValue = null; else if (metric === ImprovementDirection.Down) row.specialCauseConcernValue = null;\n\t} else {\n\t\tif (metricConflictRule === MetricConflictRule.Improvement) row.specialCauseConcernValue = null; else row.specialCauseImprovementValue = null;\n\t}\n}\n\n// Convenience helpers for diagnostics and potential UI integration\n// Compute whether any upward or downward side rules are present on a row\nexport function computeSideFlags(row: SpcRowV2): { upAny: boolean; downAny: boolean } {\n\tconst upAny = !!(row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp);\n\tconst downAny = !!(row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown);\n\treturn { upAny, downAny };\n}\n\n// True when both sides have at least one active rule (pre- or post-pruning agnostic)\nexport function hasDirectionalConflict(row: SpcRowV2): boolean {\n\tconst { upAny, downAny } = computeSideFlags(row);\n\treturn upAny && downAny;\n}\n","import {\n\tImprovementDirection,\n\tSpcRowV2,\n\tTrendSegmentationStrategy,\n} from \"../types\";\n\nexport enum TrendDirection { Up = \"Up\", Down = \"Down\" }\nexport enum MeanSide { Above = \"Above\", Below = \"Below\" }\n\nexport interface TrendSegment {\n\ttrendDirection: TrendDirection;\n\tstart: number; // inclusive index in the provided rows array\n\tend: number; // inclusive index\n\tside: MeanSide; // side of mean for all rows in this segment\n\tminValue: number;\n\tmaxValue: number;\n\tmaxAbsDeltaFromMean: number; // max |value-mean| within segment\n}\n\nexport interface TrendRun {\n\ttrendDirection: TrendDirection;\n\tstart: number;\n\tend: number; // inclusive\n\tsegments: TrendSegment[];\n}\n\nfunction signOf(x: number): -1 | 0 | 1 {\n\tif (x > 0) return 1;\n\tif (x < 0) return -1;\n\treturn 0;\n}\n\nfunction sideFor(delta: number): MeanSide | undefined {\n\tconst s = signOf(delta);\n\tif (s > 0) return MeanSide.Above;\n\tif (s < 0) return MeanSide.Below;\n\treturn undefined;\n}\n\n/**\n * Compute contiguous trend runs from backfilled trend flags, and split them into\n * mean-side-consistent segments (Above/Below) across partition mean steps.\n * Points equal to mean are treated as a boundary (not included in either side),\n * so segments will not include rows where value === mean.\n */\nexport function computeTrendSegments(\n\trows: ReadonlyArray<SpcRowV2>\n): TrendRun[] {\n\tconst runs: TrendRun[] = [];\n\n\t// Small helpers to keep the loop readable while preserving control flow\n\tconst startSegment = (\n\t\tk: number,\n\t\tinitialSide: MeanSide,\n\t\tvalue: number\n\t): {\n\t\tsegStart: number;\n\t\tsegSide: MeanSide;\n\t\tminV: number;\n\t\tmaxV: number;\n\t\tmaxAbsDelta: number;\n\t} => ({\n\t\tsegStart: k,\n\t\tsegSide: initialSide,\n\t\tminV: value,\n\t\tmaxV: value,\n\t\tmaxAbsDelta: 0, // caller sets initial delta immediately after\n\t});\n\n\tconst extendSegment = (\n\t\tvalue: number,\n\t\tdeltaAbs: number,\n\t\tminV: number,\n\t\tmaxV: number,\n\t\tmaxAbsDelta: number\n\t): { minV: number; maxV: number; maxAbsDelta: number } => ({\n\t\tminV: Math.min(minV, value),\n\t\tmaxV: Math.max(maxV, value),\n\t\tmaxAbsDelta: Math.max(maxAbsDelta, deltaAbs),\n\t});\n\n\tconst flushSegment = (\n\t\tsegments: TrendSegment[],\n\t\tsegStart: number,\n\t\tendIdx: number,\n\t\tsegSide: MeanSide,\n\t\tminV: number,\n\t\tmaxV: number,\n\t\tmaxAbsDelta: number,\n\t\tdir: TrendDirection\n\t) => {\n\t\tsegments.push({\n\t\t\ttrendDirection: dir,\n\t\t\tstart: segStart,\n\t\t\tend: endIdx,\n\t\t\tside: segSide,\n\t\t\tminValue: minV,\n\t\t\tmaxValue: maxV,\n\t\t\tmaxAbsDeltaFromMean: maxAbsDelta,\n\t\t});\n\t};\n\n\t// Build contiguous runs for trendUp and trendDown separately\n\tlet i = 0;\n\twhile (i < rows.length) {\n\t\tconst r = rows[i];\n\t\tif (!r || r.value == null || r.ghost || (!r.trendUp && !r.trendDown)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tconst dir: TrendDirection = r.trendUp\n\t\t\t? TrendDirection.Up\n\t\t\t: r.trendDown\n\t\t\t\t? TrendDirection.Down\n\t\t\t\t: (undefined as any);\n\t\t// start of run\n\t\tlet start = i;\n\t\tlet j = i;\n\t\tfor (; j < rows.length; j++) {\n\t\t\tconst rr = rows[j];\n\t\t\tif (!rr || rr.value == null || rr.ghost) break;\n\t\t\tconst sameDir = dir === TrendDirection.Up ? rr.trendUp : rr.trendDown;\n\t\t\tif (!sameDir) break;\n\t\t}\n\t\tconst end = j - 1; // inclusive\n\n\t\t// Segment this run into above/below-mean pieces\n\t\tconst segments: TrendSegment[] = [];\n\t\tlet segStart: number | undefined = undefined;\n\t\tlet segSide: MeanSide | undefined = undefined;\n\t\tlet minV = Infinity,\n\t\t\tmaxV = -Infinity,\n\t\t\tmaxAbsDelta = 0;\n\n\t\tfor (let k = start; k <= end; k++) {\n\t\t\tconst row = rows[k]!;\n\t\t\tif (row.value == null) continue;\n\t\t\tconst delta = row.value - (row.mean ?? 0);\n\t\t\tconst side = sideFor(delta);\n\n\t\t\tif (!side) {\n\t\t\t\t// value equals mean → boundary: close current seg (if any) and skip this row\n\t\t\t\tif (segStart !== undefined) {\n\t\t\t\t\tflushSegment(segments, segStart, k - 1, segSide!, minV, maxV, maxAbsDelta, dir);\n\t\t\t\t\tsegStart = undefined;\n\t\t\t\t\tsegSide = undefined;\n\t\t\t\t\tminV = Infinity;\n\t\t\t\t\tmaxV = -Infinity;\n\t\t\t\t\tmaxAbsDelta = 0;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (segStart === undefined) {\n\t\t\t\t// start new segment\n\t\t\t\t({ segStart, segSide, minV, maxV, maxAbsDelta } = (() => {\n\t\t\t\t\tconst s = startSegment(k, side, row.value);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsegStart: s.segStart,\n\t\t\t\t\t\tsegSide: s.segSide,\n\t\t\t\t\t\tminV: s.minV,\n\t\t\t\t\t\tmaxV: s.maxV,\n\t\t\t\t\t\tmaxAbsDelta: Math.abs(delta),\n\t\t\t\t\t};\n\t\t\t\t})());\n\t\t\t} else if (side !== segSide) {\n\t\t\t\t// flush previous segment and start new\n\t\t\t\tflushSegment(segments, segStart, k - 1, segSide!, minV, maxV, maxAbsDelta, dir);\n\t\t\t\t({ segStart, segSide, minV, maxV, maxAbsDelta } = (() => {\n\t\t\t\t\tconst s = startSegment(k, side, row.value);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsegStart: s.segStart,\n\t\t\t\t\t\tsegSide: s.segSide,\n\t\t\t\t\t\tminV: s.minV,\n\t\t\t\t\t\tmaxV: s.maxV,\n\t\t\t\t\t\tmaxAbsDelta: Math.abs(delta),\n\t\t\t\t\t};\n\t\t\t\t})());\n\t\t\t} else {\n\t\t\t\t// extend\n\t\t\t\tconst updated = extendSegment(row.value, Math.abs(delta), minV, maxV, maxAbsDelta);\n\t\t\t\tminV = updated.minV;\n\t\t\t\tmaxV = updated.maxV;\n\t\t\t\tmaxAbsDelta = updated.maxAbsDelta;\n\t\t\t}\n\t\t}\n\t\tif (segStart !== undefined) {\n\t\t\tflushSegment(segments, segStart, end, segSide!, minV, maxV, maxAbsDelta, dir);\n\t\t}\n\n\t\truns.push({ trendDirection: dir, start, end, segments });\n\t\ti = end + 1;\n\t}\n\n\treturn runs;\n}\n\nexport interface SegmentHighlightOptions {\n\tmetricImprovement: ImprovementDirection;\n\tstrategy?: TrendSegmentationStrategy;\n}\n\n/** Map metricImprovement to favourable mean side */\nfunction favourableSide(impr: ImprovementDirection): MeanSide | undefined {\n\tif (impr === ImprovementDirection.Up) return MeanSide.Above;\n\tif (impr === ImprovementDirection.Down) return MeanSide.Below;\n\treturn undefined;\n}\n\nfunction oppositeSide(side: MeanSide | undefined): MeanSide | undefined {\n\tif (!side) return undefined;\n\treturn side === MeanSide.Above ? MeanSide.Below : MeanSide.Above;\n}\n\n/**\n * Choose segments to highlight from a computed run set using a strategy.\n * - FavourableSide: highlight all segments on the favourable side of mean\n * - CrossingAfterFavourable: if a side change occurs, highlight only the first favourable-side\n *   segment after a crossing; otherwise fall back to FavourableSide\n * - ExtremeFavourable: pick the favourable-side segment with the largest |value-mean| extremum\n */\nexport function chooseSegmentsForHighlight(\n\truns: TrendRun[],\n\topts: SegmentHighlightOptions\n): TrendSegment[] {\n\n\tconst strategy = opts.strategy ?? TrendSegmentationStrategy.CrossingAfterFavourable;\n\tconst fav = favourableSide(opts.metricImprovement);\n\tconst unfav = oppositeSide(fav);\n\n\tconst highlight: TrendSegment[] = [];\n\n\tfor (const run of runs) {\n\t\tif (!fav) {\n\t\t\t// Neither: no inherent favourable side; choose the segment with largest absolute distance\n\t\t\tif (\n\t\t\t\tstrategy === TrendSegmentationStrategy.ExtremeFavourable ||\n\t\t\t\tstrategy === TrendSegmentationStrategy.CrossingAfterFavourable\n\t\t\t) {\n\t\t\t\tconst all = run.segments;\n\t\t\t\tif (all.length === 0) continue;\n\t\t\t\tlet best = all[0];\n\t\t\t\tfor (const s of all)\n\t\t\t\t\tif (s.maxAbsDeltaFromMean > best.maxAbsDeltaFromMean) best = s;\n\t\t\t\thighlight.push(best);\n\t\t\t} else {\n\t\t\t\t// FavourableSide in Neither -> nothing by default\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FavourableSide) {\n\t\t\thighlight.push(...run.segments.filter((s) => s.side === fav));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.UnfavourableSide) {\n\t\t\thighlight.push(...run.segments.filter((s) => s.side === unfav));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.CrossingAfterFavourable) {\n\t\t\t// Detect first segment with fav side that is preceded by a different side\n\t\t\tconst segs = run.segments;\n\t\t\tlet chosen: TrendSegment | undefined = undefined;\n\t\t\tfor (let idx = 0; idx < segs.length; idx++) {\n\t\t\t\tconst s = segs[idx];\n\t\t\t\tif (s.side === fav) {\n\t\t\t\t\tif (idx > 0 && segs[idx - 1].side !== fav) {\n\t\t\t\t\t\tchosen = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// if run starts already on favourable side and never crosses, fall back later\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chosen) {\n\t\t\t\t// fall back: pick the longest favourable segment (by length) if any\n\t\t\t\tconst favSegs = segs.filter((s) => s.side === fav);\n\t\t\t\tif (favSegs.length > 0) {\n\t\t\t\t\tchosen = favSegs.reduce(\n\t\t\t\t\t\t(a, b) => (b.end - b.start > a.end - a.start ? b : a),\n\t\t\t\t\t\tfavSegs[0]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chosen) highlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.CrossingAfterUnfavourable) {\n\t\t\tconst segs = run.segments;\n\t\t\tlet chosen: TrendSegment | undefined = undefined;\n\t\t\tfor (let idx = 0; idx < segs.length; idx++) {\n\t\t\t\tconst s = segs[idx];\n\t\t\t\tif (s.side === unfav) {\n\t\t\t\t\tif (idx > 0 && segs[idx - 1].side !== unfav) {\n\t\t\t\t\t\tchosen = s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chosen) {\n\t\t\t\tconst unSegs = segs.filter((s) => s.side === unfav);\n\t\t\t\tif (unSegs.length > 0) {\n\t\t\t\t\tchosen = unSegs.reduce(\n\t\t\t\t\t\t(a, b) => (b.end - b.start > a.end - a.start ? b : a),\n\t\t\t\t\t\tunSegs[0]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chosen) highlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.ExtremeFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\tconst chosen = favSegs.reduce((a, b) =>\n\t\t\t\tb.maxAbsDeltaFromMean > a.maxAbsDeltaFromMean ? b : a\n\t\t\t);\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.ExtremeUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\tconst chosen = unSegs.reduce((a, b) => (b.maxAbsDeltaFromMean > a.maxAbsDeltaFromMean ? b : a));\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FirstFavourable) {\n\t\t\tconst seg = run.segments.find((s) => s.side === fav);\n\t\t\tif (seg) highlight.push(seg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.FirstUnfavourable) {\n\t\t\tconst seg = run.segments.find((s) => s.side === unfav);\n\t\t\tif (seg) highlight.push(seg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LongestFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\tconst chosen = favSegs.reduce((a, b) =>\n\t\t\t\tb.end - b.start > a.end - a.start ? b : a\n\t\t\t);\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LongestUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\tconst chosen = unSegs.reduce((a, b) => (b.end - b.start > a.end - a.start ? b : a));\n\t\t\thighlight.push(chosen);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LastFavourable) {\n\t\t\tconst favSegs = run.segments.filter((s) => s.side === fav);\n\t\t\tif (favSegs.length === 0) continue;\n\t\t\thighlight.push(favSegs[favSegs.length - 1]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strategy === TrendSegmentationStrategy.LastUnfavourable) {\n\t\t\tconst unSegs = run.segments.filter((s) => s.side === unfav);\n\t\t\tif (unSegs.length === 0) continue;\n\t\t\thighlight.push(unSegs[unSegs.length - 1]);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn highlight;\n}\n","import { ImprovementDirection, SpcRowV2, VariationIcon } from \"../types\";\n\n// Engine-level visual categories (UI-agnostic). Keep separate from VariationIcon.\nexport enum SpcVisualCategory {\n\tCommon = \"Common\",\n\tImprovement = \"Improvement\",\n\tConcern = \"Concern\",\n\tNoJudgement = \"NoJudgement\",\n}\n\nexport enum TrendVisualMode {\n  Ungated = \"Ungated\",\n  Gated = \"Gated\",\n}\n\nexport interface VisualCategoryOptions {\n\tmetricImprovement: ImprovementDirection;\n\ttrendVisualMode?: TrendVisualMode; // default Ungated\n\tenableNeutralNoJudgement?: boolean; // default true\n}\n\n// Derive upAny/downAny flags from a row's directional rule flags\nfunction sideFlags(row: SpcRowV2): { upAny: boolean; downAny: boolean } {\n\tconst upAny = !!(\n\t\trow.singlePointUp ||\n\t\trow.twoSigmaUp ||\n\t\trow.shiftUp ||\n\t\trow.trendUp\n\t);\n\tconst downAny = !!(\n\t\trow.singlePointDown ||\n\t\trow.twoSigmaDown ||\n\t\trow.shiftDown ||\n\t\trow.trendDown\n\t);\n\treturn { upAny, downAny };\n}\n\n/**\n * Compute per-point visual categories from engine rows.\n *\n * Rules\n * - If both upAny and downAny → Improvement (prefer improvement in conflict)\n * - Else honour engine VariationIcon for improvement/concern\n * - Else when VariationIcon is a Neither* and any special-cause fired:\n *   - Ungated: colour directionally by metricImprovement and side\n *   - Otherwise: NoJudgement when enabled\n * - Else Common\n */\nexport function computeSpcVisualCategories(\n\trows: ReadonlyArray<SpcRowV2>,\n\topts: VisualCategoryOptions\n): SpcVisualCategory[] {\n\tconst metricImprovement = opts.metricImprovement;\n\tconst trendVisualMode: TrendVisualMode = opts.trendVisualMode ?? TrendVisualMode.Ungated;\n\tconst enableNeutral = opts.enableNeutralNoJudgement ?? true;\n\n\treturn rows.map((row) => {\n\t\tif (!row || row.value == null || row.ghost) return SpcVisualCategory.Common;\n\t\tconst { upAny, downAny } = sideFlags(row);\n\n\t\t// Conflict tie-break: prefer Improvement\n\t\tif (upAny && downAny) return SpcVisualCategory.Improvement;\n\n\t\t// Honour engine variation categories first\n\t\tswitch (row.variationIcon) {\n\t\t\tcase VariationIcon.ImprovementHigh:\n\t\t\tcase VariationIcon.ImprovementLow:\n\t\t\t\treturn SpcVisualCategory.Improvement;\n\t\t\tcase VariationIcon.ConcernHigh:\n\t\t\tcase VariationIcon.ConcernLow:\n\t\t\t\treturn SpcVisualCategory.Concern;\n\t\t\tcase VariationIcon.NeitherHigh:\n\t\t\tcase VariationIcon.NeitherLow: {\n\t\t\t\t// Neither metric: treat as neutral special-cause; allow ungated directional colour\n\t\t\t\tif (\n\t\t\t\t\ttrendVisualMode === TrendVisualMode.Ungated &&\n\t\t\t\t\tmetricImprovement !== ImprovementDirection.Neither\n\t\t\t\t) {\n\t\t\t\t\tif (upAny && !downAny) {\n\t\t\t\t\t\treturn metricImprovement === ImprovementDirection.Up\n\t\t\t\t\t\t\t? SpcVisualCategory.Improvement\n\t\t\t\t\t\t\t: SpcVisualCategory.Concern;\n\t\t\t\t\t}\n\t\t\t\t\tif (downAny && !upAny) {\n\t\t\t\t\t\treturn metricImprovement === ImprovementDirection.Down\n\t\t\t\t\t\t\t? SpcVisualCategory.Improvement\n\t\t\t\t\t\t\t: SpcVisualCategory.Concern;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn enableNeutral\n\t\t\t\t\t? SpcVisualCategory.NoJudgement\n\t\t\t\t\t: SpcVisualCategory.Common;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn SpcVisualCategory.Common;\n\t\t}\n\t});\n}\n\nexport default { computeSpcVisualCategories, SpcVisualCategory };\n","import { ImprovementDirection, SpcRowV2 } from \"../types\";\nimport {\n\tSpcVisualCategory,\n\tcomputeSpcVisualCategories,\n\tTrendVisualMode,\n} from \"./visualCategories\";\n\nexport type BoundaryWindowsMode = \"Disabled\" | \"RecalcCrossing\";\n\nexport interface BoundaryWindowsOptions {\n\tmode?: BoundaryWindowsMode; // default: Disabled\n\tpreWindow?: number; // default: 2 (points immediately before boundary)\n\tpostWindow?: number; // default: 3 (points starting at boundary)\n\t/**\n\t * Controls the polarity of the pre-window category relative to the post-window.\n\t * - \"Opposite\" (default): pre-window uses the opposite category of post-window (contrast around boundary)\n\t * - \"Same\": pre-window uses the same category as post-window (uniform window around boundary)\n\t */\n\tprePolarity?: \"Opposite\" | \"Same\";\n\t/**\n\t * Optional explicit boundary indices to use instead of auto-detecting via partitionId changes.\n\t * Each index should correspond to the first point of a new partition (i.e., the baseline-marked row).\n\t */\n\tboundaryIndices?: number[];\n}\n\n/**\n * Compute visual categories with optional boundary-aware post-classification adjustments.\n *\n * Behaviour (RecalcCrossing):\n * - Detect each partition boundary (partitionId changes).\n * - Compute mean delta: first non-null mean in new partition minus last non-null mean in previous partition.\n * - Determine favourable direction based on metricImprovement (Up -> delta>0, Down -> delta<0).\n * - Apply small windows around the boundary:\n *   - postWindow points [boundary .. boundary+postWindow-1]: set to Improvement if favourable else Concern\n *   - preWindow points [boundary-preWindow .. boundary-1]: set to the opposite category\n * - Never override existing Improvement/Concern categories from base computation; only upgrade\n *   Common/NoJudgement into the window categories.\n * - If metricImprovement === Neither, or either side has no eligible mean, no adjustments are applied for that boundary.\n */\nexport function computeBoundaryWindowCategories(\n\trows: ReadonlyArray<SpcRowV2>,\n\tmetricImprovement: ImprovementDirection,\n\toptions?: BoundaryWindowsOptions\n): SpcVisualCategory[] {\n\tconst mode = options?.mode ?? \"Disabled\";\n\tif (!rows.length) return [];\n\t// Start from base visual categories\n\tlet out = computeSpcVisualCategories(rows, {\n\t\tmetricImprovement,\n\t\ttrendVisualMode: TrendVisualMode.Ungated,\n\t\tenableNeutralNoJudgement: true,\n\t});\n\n\tif (mode !== \"RecalcCrossing\") return out;\n\tif (metricImprovement === ImprovementDirection.Neither) return out;\n\n\tconst preWin = Math.max(0, options?.preWindow ?? 2);\n\tconst postWin = Math.max(0, options?.postWindow ?? 3);\n\tconst prePolarity = options?.prePolarity ?? \"Opposite\";\n\n\t// Helper: safely set category if current is Common/NoJudgement only\n\tconst setIfUpgrade = (idx: number, cat: SpcVisualCategory) => {\n\t\tif (idx < 0 || idx >= out.length) return;\n\t\tconst cur = out[idx];\n\t\tif (\n\t\t\tcur === SpcVisualCategory.Common ||\n\t\t\tcur === SpcVisualCategory.NoJudgement\n\t\t) {\n\t\t\tout[idx] = cat;\n\t\t}\n\t};\n\n\t// Fallback mean when eligibility-gated means are unavailable: average raw values in the partition\n\tconst partitionFallbackMean = (\n\t\tpid: number | string | null\n\t): number | null => {\n\t\tif (pid == null) return null;\n\t\tconst values = rows.reduce<number[]>((acc, r) => {\n\t\t\tif (\n\t\t\t\tr.partitionId === pid &&\n\t\t\t\ttypeof r.value === \"number\" &&\n\t\t\t\t!r.ghost\n\t\t\t) {\n\t\t\t\tacc.push(r.value);\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t\tif (!values.length) return null;\n\t\tconst sum = values.reduce((a, b) => a + b, 0);\n\t\treturn sum / values.length;\n\t};\n\n\t// Build list of boundary indices: prefer explicit list, otherwise detect by partitionId changes\n\tconst boundaries: number[] =\n\t\tArray.isArray(options?.boundaryIndices) && options!.boundaryIndices!.length\n\t\t\t? options!.boundaryIndices!.slice().filter((b) => Number.isFinite(b))\n\t\t\t: (() => {\n\t\t\t\treturn rows.reduce<number[]>((acc, cur, i) => {\n\t\t\t\t\tif (i === 0) return acc;\n\t\t\t\t\tconst prev = rows[i - 1];\n\t\t\t\t\tif (prev && cur && cur.partitionId !== prev.partitionId) {\n\t\t\t\t\t\tacc.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn acc;\n\t\t\t\t}, []);\n\t\t\t})();\n\n\tfor (const boundary of boundaries) {\n\t\tconst prev = rows[boundary - 1];\n\t\tconst cur = rows[boundary];\n\t\tif (!prev || !cur) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Determine contiguous segment bounds for the two partitions touching this boundary\n\t\tlet prevStart = boundary - 1;\n\t\twhile (\n\t\t\tprevStart - 1 >= 0 &&\n\t\t\trows[prevStart - 1] &&\n\t\t\trows[prevStart - 1].partitionId === prev.partitionId\n\t\t) {\n\t\t\tprevStart--;\n\t\t}\n\t\tlet curEnd = boundary;\n\t\twhile (\n\t\t\tcurEnd + 1 < rows.length &&\n\t\t\trows[curEnd + 1] &&\n\t\t\trows[curEnd + 1].partitionId === cur.partitionId\n\t\t) {\n\t\t\tcurEnd++;\n\t\t}\n\n\t\t// Find last non-null mean in previous partition\n\t\tlet oldMean: number | null = null;\n\t\tfor (let j = boundary - 1; j >= 0; j--) {\n\t\t\tconst r = rows[j];\n\t\t\tif (r.partitionId !== prev.partitionId) break;\n\t\t\tif (typeof r.mean === \"number\") {\n\t\t\t\toldMean = r.mean;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// Find first non-null mean in new partition\n\t\tlet newMean: number | null = null;\n\t\tfor (let k = boundary; k < rows.length; k++) {\n\t\t\tconst r = rows[k];\n\t\t\tif (r.partitionId !== cur.partitionId) break;\n\t\t\tif (typeof r.mean === \"number\") {\n\t\t\t\tnewMean = r.mean;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// If eligibility prevented means from materialising on either side, fall back to raw partition averages\n\t\tif (oldMean == null)\n\t\t\toldMean = partitionFallbackMean(prev.partitionId ?? null);\n\t\tif (newMean == null)\n\t\t\tnewMean = partitionFallbackMean(cur.partitionId ?? null);\n\t\tif (oldMean == null || newMean == null) {\n\t\t\t// still insufficient info\n\t\t\tcontinue;\n\t\t}\n\t\tconst delta = newMean - oldMean;\n\t\tconst favourable =\n\t\t\tmetricImprovement === ImprovementDirection.Up ? delta > 0 : delta < 0;\n\t\tconst postCat = favourable\n\t\t\t? SpcVisualCategory.Improvement\n\t\t\t: SpcVisualCategory.Concern;\n\t\tconst preCat =\n\t\t\tprePolarity === \"Same\"\n\t\t\t\t? postCat\n\t\t\t\t: favourable\n\t\t\t\t\t? SpcVisualCategory.Concern\n\t\t\t\t\t: SpcVisualCategory.Improvement;\n\n\t\t// Apply pre-window (clamped to previous partition only)\n\t\tfor (let p = 1; p <= preWin; p++) {\n\t\t\tconst idx = boundary - p;\n\t\t\tif (idx < prevStart) break;\n\t\t\tsetIfUpgrade(idx, preCat);\n\t\t}\n\t\t// Apply post-window (clamped to current partition only)\n\t\tfor (let p = 0; p < postWin; p++) {\n\t\t\tconst idx = boundary + p;\n\t\t\tif (idx > curEnd) break;\n\t\t\tsetIfUpgrade(idx, postCat);\n\t\t}\n\t}\n\n\treturn out;\n}\n\nexport default { computeBoundaryWindowCategories };\n","import {\n\tSpcSettingsHierarchical,\n\tSpcSettingsInput,\n\tSpcSettingsV26a,\n} from \"./types\";\n\n// Public helper: normalise v2 settings. Accepts flat (v2.6a) or hierarchical input and returns canonical flat settings.\nexport function normaliseSpcSettingsV2(\n\tinput?: SpcSettingsInput\n): SpcSettingsV26a {\n\tif (!input) return {} as SpcSettingsV26a;\n\t// If it looks like flat settings, return as-is\n\tif (\n\t\ttypeof input === \"object\" &&\n\t\t(\"minimumPoints\" in (input as any) ||\n\t\t\t\"shiftPoints\" in (input as any) ||\n\t\t\t\"trendPoints\" in (input as any))\n\t) {\n\t\treturn input as SpcSettingsV26a;\n\t}\n\tconst h = input as SpcSettingsHierarchical;\n\tconst out: SpcSettingsV26a = {};\n\t// thresholds\n\tif (h.thresholds) {\n\t\tconst t = h.thresholds;\n\t\tif (t.minimumPoints != null) out.minimumPoints = t.minimumPoints;\n\t\tif (t.shiftPoints != null) out.shiftPoints = t.shiftPoints;\n\t\tif (t.trendPoints != null) out.trendPoints = t.trendPoints;\n\t\tif (t.excludeMovingRangeOutliers != null)\n\t\t\tout.excludeMovingRangeOutliers = t.excludeMovingRangeOutliers;\n\t}\n\t// eligibility\n\tif (h.eligibility) {\n\t\tif (h.eligibility.chartLevel != null)\n\t\t\tout.chartLevelEligibility = h.eligibility.chartLevel;\n\t}\n\t// parity\n\tif (h.parity) {\n\t\tif (h.parity.trendAcrossPartitions != null)\n\t\t\tout.trendAcrossPartitions = h.parity.trendAcrossPartitions;\n\t\tif (h.parity.twoSigmaIncludeAboveThree != null)\n\t\t\tout.twoSigmaIncludeAboveThree = h.parity.twoSigmaIncludeAboveThree;\n\t\tif (h.parity.enableFourOfFiveRule != null)\n\t\t\tout.enableFourOfFiveRule = h.parity.enableFourOfFiveRule;\n\t}\n\t// conflict\n\tif (h.conflict) {\n\t\tif (h.conflict.preferImprovementWhenConflict != null)\n\t\t\tout.preferImprovementWhenConflict =\n\t\t\t\th.conflict.preferImprovementWhenConflict;\n\t\tif (h.conflict.preferTrendWhenConflict != null)\n\t\t\tout.preferTrendWhenConflict = h.conflict.preferTrendWhenConflict;\n\t\tif (h.conflict.strategy != null) out.conflictStrategy = h.conflict.strategy;\n\t\tif (h.conflict.ruleHierarchy != null)\n\t\t\tout.ruleHierarchy = h.conflict.ruleHierarchy;\n\t\tif (h.conflict.metricRuleOnTie != null)\n\t\t\tout.metricConflictRule = h.conflict.metricRuleOnTie;\n\t}\n\t// trend\n\tif (h.trend?.segmentation) {\n\t\tconst s = h.trend.segmentation;\n\t\tif (s.mode != null) out.trendSegmentationMode = s.mode;\n\t\tif (s.favourableSegmentation != null)\n\t\t\tout.trendFavourableSegmentation = s.favourableSegmentation;\n\t\tif (s.strategy != null) out.trendSegmentationStrategy = s.strategy;\n\t\tif (s.dominatesHighlightedWindow != null)\n\t\t\tout.trendDominatesHighlightedWindow = s.dominatesHighlightedWindow;\n\t}\n\treturn out;\n}\n","import {\n\tBuildArgsV2,\n\tConflictStrategy,\n\tImprovementDirection,\n\tMetricConflictRule,\n\tTrendSegmentationStrategy,\n\tTrendSegmentationMode,\n\tSpcResultV2,\n\tSpcRowV2,\n\tVariationIcon,\n} from \"./types\";\nimport { computePartitionLimits } from \"./limits\";\nimport { detectRulesInPartition } from \"./detector\";\nimport { applySqlPruning, deriveOriginalCandidates } from \"./conflict\";\nimport { computeTrendSegments, chooseSegmentsForHighlight, TrendDirection } from \"./postprocess/trendSegments\";\nimport { computeSpcVisualCategories, SpcVisualCategory, TrendVisualMode } from \"./postprocess/visualCategories\";\nimport { computeBoundaryWindowCategories, BoundaryWindowsOptions } from \"./postprocess/boundaryWindows\";\nimport { isNumber } from \"./utils\";\nimport { normaliseSpcSettingsV2 } from \"./normaliser\";\n//\n\n// Build an SPC result aligned to SQL v2.6a, focusing on XmR.\n// Mirrors SQL steps but emits per-row icons; dataset parity compares the last non-ghosted row.\nexport function buildSpcV26a(args: BuildArgsV2): SpcResultV2 {\n\tconst { chartType, metricImprovement, data } = args;\n\n\t// There is a legacy flat settings file and a new structured one; normalise to the flat form\n\tconst settings = normaliseSpcSettingsV2(args.settings);\n\n\t// Consolidate with defaults derived from NHSE SQL v2.6a and Making Data Count guidance\n\tconst s = {\n\t\tminimumPoints: 13,\n\t\tshiftPoints: 6,\n\t\ttrendPoints: 6,\n\t\texcludeMovingRangeOutliers: false,\n\t\tmetricConflictRule: MetricConflictRule.Improvement,\n\t\ttrendAcrossPartitions: false,\n\t\ttwoSigmaIncludeAboveThree: false,\n\t\tenableFourOfFiveRule: false,\n\t\tpreferImprovementWhenConflict: false,\n\t\tconflictStrategy: ConflictStrategy.SqlPrimeThenRule,\n\t\truleHierarchy: undefined,\n\t\tchartLevelEligibility: false,\n\t\ttrendFavourableSegmentation: false,\n\t\ttrendSegmentationMode: TrendSegmentationMode.Off,\n\t\ttrendSegmentationStrategy: TrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\ttrendDominatesHighlightedWindow: false,\n\t\t...settings,\n\t};\n\n\t// Resolve legacy boolean to mode if provided explicitly in settings\n\tconst resolvedMode: TrendSegmentationMode =\n\t\tsettings?.trendSegmentationMode ||\n\t\t(settings?.trendFavourableSegmentation === true\n\t\t\t? TrendSegmentationMode.Always\n\t\t\t: settings?.trendFavourableSegmentation === false\n\t\t\t? TrendSegmentationMode.Off\n\t\t\t: s.trendSegmentationMode!);\n\n\t// Canonical rows — ensure predictable structure and types used throughout the build\n\tconst canon = data.map((d, i) => ({\n\t\trowId: i + 1,\n\t\tx: d.x,\n\t\tvalue: isNumber(d.value) ? d.value! : null,\n\t\tghost: !!d.ghost,\n\t\tbaseline: !!d.baseline,\n\t\ttarget: isNumber(d.target) ? d.target! : null,\n\t}));\n\n\t// Partitioning — split series at baseline markers (inclusive), calculations occur within these partitions\n\tconst partitions: (typeof canon)[] = [];\n\tlet cur: typeof canon = [];\n\tfor (const r of canon) {\n\t\tif (r.baseline && cur.length) {\n\t\t\tpartitions.push(cur);\n\t\t\tcur = [];\n\t\t}\n\t\tcur.push(r);\n\t}\n\tif (cur.length) partitions.push(cur);\n\n\tconst out: SpcRowV2[] = [];\n\n\t// Global gating for trend segmentation: when preferImprovementWhenConflict is enabled,\n\t// we disable trend segmentation to better match datasets that expect improvement-side dominance\n\t// without segment masking side-effects around the mean crossings.\n\tconst segmentationEnabled =\n\t\t(s.trendFavourableSegmentation || resolvedMode !== TrendSegmentationMode.Off) &&\n\t\t!s.preferImprovementWhenConflict;\n\n\t// Determine chart-level eligibility when enabled: count all non-ghost, valued points across the chart\n\tconst totalEligiblePoints = canon.filter((r) => !r.ghost && isNumber(r.value)).length;\n\tconst chartEligible = !!s.chartLevelEligibility && totalEligiblePoints >= (s.minimumPoints!);\n\tlet partitionId = 0;\n\tfor (const part of partitions) {\n\t\tpartitionId++;\n\t\tconst values = part.map((p) => p.value);\n\t\tconst ghosts = part.map((p) => p.ghost);\n\n\t\t// Eligibility: gate control lines per-row within each partition based on pointRank\n\t\t// A row becomes eligible when there are at least `minimumPoints` non-ghost, valued points in its partition up to and including that row.\n\t\t// This ensures that control lines are only drawn when there is sufficient data.\n\t\tconst lim = computePartitionLimits(\n\t\t\tchartType,\n\t\t\tvalues,\n\t\t\tghosts,\n\t\t\t!!s.excludeMovingRangeOutliers\n\t\t);\n\n\t\t// Build rows with limits and eligibility\n\t\tconst withLines: SpcRowV2[] = part.map((r, i) => {\n\t\t\tconst pointRank =\n\t\t\t\t!r.ghost && isNumber(r.value)\n\t\t\t\t\t? values.slice(0, i + 1).filter((v, j) => !ghosts[j] && isNumber(v)).length\n\t\t\t\t\t: 0;\n\t\t\tconst eligibleHere = chartEligible ? true : pointRank >= (s.minimumPoints!);\n\t\t\treturn {\n\t\t\trowId: r.rowId,\n\t\t\tx: r.x,\n\t\t\tvalue: isNumber(r.value) ? r.value : null,\n\t\t\tghost: r.ghost,\n\t\t\tpartitionId,\n\t\t\tpointRank,\n\t\t\tmean: (eligibleHere || chartEligible) && isNumber(lim.mean) ? lim.mean : null,\n\t\t\tupperProcessLimit: (eligibleHere || chartEligible) ? lim.upperProcessLimit : null,\n\t\t\tlowerProcessLimit: (eligibleHere || chartEligible) ? lim.lowerProcessLimit : null,\n\t\t\tupperTwoSigma: (eligibleHere || chartEligible) ? lim.upperTwoSigma : null,\n\t\t\tlowerTwoSigma: (eligibleHere || chartEligible) ? lim.lowerTwoSigma : null,\n\t\t\tupperOneSigma: (eligibleHere || chartEligible) ? lim.upperOneSigma : null,\n\t\t\tlowerOneSigma: (eligibleHere || chartEligible) ? lim.lowerOneSigma : null,\n\t\t\t// rules\n\t\t\tsinglePointUp: false,\n\t\t\tsinglePointDown: false,\n\t\t\ttwoSigmaUp: false,\n\t\t\ttwoSigmaDown: false,\n\t\t\tfourOfFiveUp: false,\n\t\t\tfourOfFiveDown: false,\n\t\t\tshiftUp: false,\n\t\t\tshiftDown: false,\n\t\t\ttrendUp: false,\n\t\t\ttrendDown: false,\n\t\t\t// candidates\n\t\t\tspecialCauseImprovementValue: null,\n\t\t\tspecialCauseConcernValue: null,\n\t\t\tvariationIcon: VariationIcon.CommonCause,\n\t\t};\n\t\t});\n\n\t\t// Pass 1: single 3-sigma — mark any point beyond upper/lower process limits\n\t\tfor (const row of withLines) {\n\t\t\tif (\n\t\t\t\trow.ghost ||\n\t\t\t\t!isNumber(row.value) ||\n\t\t\t\trow.mean === null\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tif (\n\t\t\t\tisNumber(row.upperProcessLimit) &&\n\t\t\t\trow.value! > row.upperProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointUp = true;\n\t\t\tif (\n\t\t\t\tisNumber(row.lowerProcessLimit) &&\n\t\t\t\trow.value! < row.lowerProcessLimit!\n\t\t\t)\n\t\t\t\trow.singlePointDown = true;\n\t\t}\n\n\t\t// Pass 2: patterns — shift, two-of-three, strict monotonic trend (per-partition)\n\t\tdetectRulesInPartition(withLines, {\n\t\t\tshiftPoints: s.shiftPoints!,\n\t\t\ttrendPoints: s.trendPoints!,\n\t\t\ttwoSigmaIncludeAboveThree: !!s.twoSigmaIncludeAboveThree,\n\t\t\tenableFourOfFiveRule: !!s.enableFourOfFiveRule,\n\t\t});\n\n\t\t// Optional post-detection step: trend favourable segmentation to resolve cross-mean conflicts\n\t\tconst maybeApplySegmentation = (rows: SpcRowV2[]) => {\n\t\t\t// Determine if this partition has any potential conflicts (both sides active on any row)\n\t\t\tconst hasConflict = rows.some((r) =>\n\t\t\t\t(r.singlePointUp || r.twoSigmaUp || r.shiftUp || r.trendUp) &&\n\t\t\t\t(r.singlePointDown || r.twoSigmaDown || r.shiftDown || r.trendDown)\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresolvedMode === TrendSegmentationMode.Off ||\n\t\t\t\t(resolvedMode === TrendSegmentationMode.AutoWhenConflict && !hasConflict)\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Apply segmentation to determine favourable trend segments to highlight\n\t\t\t// and use these to mask out trend flags that are not part of a highlighted segment.\n\t\t\t// This ensures that only rules aligned with the favourable trend segments can survive pruning.\n\t\t\t// Note: this does not affect the base rule flags, only whether they can survive pruning.\n\t\t\t// This means that the visual categories (which are computed later) may still show\n\t\t\tconst runs = computeTrendSegments(rows);\n\n\t\t\t// Choose segments to highlight based on the configured strategy\n\t\t\t// (this also filters out short segments that do not meet the trendPoints threshold)\n\t\t\tconst highlights = chooseSegmentsForHighlight(runs, {\n\t\t\t\tmetricImprovement,\n\t\t\t\tstrategy: s.trendSegmentationStrategy,\n\t\t\t});\n\n\t\t\t// Build directional allow masks so a row can only retain the trend flag\n\t\t\t// corresponding to the highlighted segment's direction it belongs to.\n\t\t\tconst allowUp = new Set<number>();\n\t\t\tconst allowDown = new Set<number>();\n\t\t\tfor (const seg of highlights) {\n\t\t\t\tfor (let k = seg.start; k <= seg.end; k++) {\n\t\t\t\t\tif (seg.trendDirection === TrendDirection.Up) allowUp.add(k);\n\t\t\t\t\telse allowDown.add(k);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Mask out trend flags that are not part of a highlighted segment\n\t\t\t// (other rule flags are unaffected)\n\t\t\trows.forEach((row, idx) => {\n\t\t\t\t// Recode trend flags to only keep those explicitly allowed by highlighted segments\n\t\t\t\trow.trendUp = allowUp.has(idx) ? row.trendUp : false;\n\t\t\t\trow.trendDown = allowDown.has(idx) ? row.trendDown : false;\n\t\t\t\t// Optional: let trend dominate inside highlighted window by clearing opposite-side non-trend flags\n\t\t\t\tif (s.trendDominatesHighlightedWindow) {\n\t\t\t\t\tif (allowUp.has(idx)) {\n\t\t\t\t\t\t// Inside an upward trend segment: drop down-side non-trend rules\n\t\t\t\t\t\trow.singlePointDown = false;\n\t\t\t\t\t\trow.twoSigmaDown = false;\n\t\t\t\t\t\trow.shiftDown = false;\n\t\t\t\t\t} else if (allowDown.has(idx)) {\n\t\t\t\t\t\t// Inside a downward trend segment: drop up-side non-trend rules\n\t\t\t\t\t\trow.singlePointUp = false;\n\t\t\t\t\t\trow.twoSigmaUp = false;\n\t\t\t\t\t\trow.shiftUp = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t// Apply segmentation if enabled and there is any conflict to resolve\n\t\t// (otherwise segmentation is skipped to avoid unnecessary side-effects)\n\t\tif (segmentationEnabled) {\n\t\t\tmaybeApplySegmentation(withLines);\n\t\t}\n\n\t\t// Candidate formation and pruning for all rows (engine v2.6a parity)\n\t\tfor (const row of withLines) {\n\t\t\t// Skip ghost rows and those without a valid value/mean\n\t\t\t// (these remain as CommonCause with no candidates)\n\t\t\tif (row.ghost || !isNumber(row.value) || row.mean === null) {\n\t\t\t\tout.push(row);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Derive original candidates from unpruned rule flags\n\t\t\t// (these are later pruned to yield the final candidates)\n\t\t\t// Note: for Neither metrics, candidates are still derived but not used in pruning\n\t\t\t// as NeitherHigh/NeitherLow icons are determined directly from rule flags.\n\t\t\tconst { aligned, opposite } = deriveOriginalCandidates(\n\t\t\t\trow,\n\t\t\t\tmetricImprovement\n\t\t\t);\n\t\t\trow.specialCauseImprovementValue = aligned ? row.value! : null;\n\t\t\trow.specialCauseConcernValue = opposite ? row.value! : null;\n\t\t\t\n\t\t\t\t\tif (metricImprovement === ImprovementDirection.Neither) {\n\t\t\t\t\t\t// Neither semantics: high-side rules -> NeitherHigh, low-side rules -> NeitherLow, else CommonCause\n\t\t\t\t\t\tconst highSide = row.singlePointUp || row.twoSigmaUp || row.shiftUp || row.trendUp;\n\t\t\t\t\t\tconst lowSide = row.singlePointDown || row.twoSigmaDown || row.shiftDown || row.trendDown;\n\t\t\t\t\t\trow.variationIcon = highSide ? VariationIcon.NeitherHigh : lowSide ? VariationIcon.NeitherLow : VariationIcon.CommonCause;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Up/Down metrics: apply SQL-style pruning and then set icon via pruning outcome\n\t\t\t\t\t\tapplySqlPruning(row, metricImprovement, s.metricConflictRule!, s.preferImprovementWhenConflict === true, s.conflictStrategy, s.ruleHierarchy, s.preferTrendWhenConflict === true);\n\t\t\t\t\t}\n\t\t\t\n\t\t\tout.push(row);\n\t\t}\n\t}\n\n\t// Optional global trend detection across partitions (SQL v2.2+):\n\tif (s.trendAcrossPartitions) {\n\t\t// Build a flat, ordered index of all non-ghost, valued rows\n\t\tconst all = out.map((r, i) => ({ idx: i, r })).filter(({ r }) => !r.ghost && isNumber(r.value));\n\t\tif (all.length >= s.trendPoints!) {\n\t\t\tfor (let w = 0; w <= all.length - s.trendPoints!; w++) {\n\t\t\t\tconst win = all.slice(w, w + s.trendPoints!).map((p) => p.idx);\n\t\t\t\tconst seq = win.map((i) => out[i]);\n\t\t\t\tif (!seq.every((row) => isNumber(row.value))) continue;\n\t\t\t\tlet inc = true;\n\t\t\t\tlet dec = true;\n\t\t\t\tfor (let k = 1; k < seq.length; k++) {\n\t\t\t\t\tif (!(seq[k].value! > seq[k - 1].value!)) inc = false;\n\t\t\t\t\tif (!(seq[k].value! < seq[k - 1].value!)) dec = false;\n\t\t\t\t\tif (!inc && !dec) break;\n\t\t\t\t}\n\t\t\t\tif (inc) win.forEach((i) => (out[i].trendUp = true));\n\t\t\t\tif (dec) win.forEach((i) => (out[i].trendDown = true));\n\t\t\t}\n\t\t}\n\t}\n\n\t// If global trend flags were added post hoc, re-apply pruning to stabilise variationIcon with updated rule flags\n\tif (s.trendAcrossPartitions) {\n\t\t// Optional: apply favourable trend segmentation across the whole series\n\t\tif (segmentationEnabled) {\n\t\t\tconst hasConflict = out.some((r) =>\n\t\t\t\t(r.singlePointUp || r.twoSigmaUp || r.shiftUp || r.trendUp) &&\n\t\t\t\t(r.singlePointDown || r.twoSigmaDown || r.shiftDown || r.trendDown)\n\t\t\t);\n\t\t\tif (\n\t\t\t\tresolvedMode === TrendSegmentationMode.Always ||\n\t\t\t\t(resolvedMode === TrendSegmentationMode.AutoWhenConflict && hasConflict)\n\t\t\t) {\n\t\t\tconst runs = computeTrendSegments(out);\n\t\t\tconst highlights = chooseSegmentsForHighlight(runs, { metricImprovement, strategy: s.trendSegmentationStrategy });\n\t\t\tconst allowUp = new Set<number>();\n\t\t\tconst allowDown = new Set<number>();\n\t\t\tfor (const seg of highlights) {\n\t\t\t\tfor (let k = seg.start; k <= seg.end; k++) {\n\t\t\t\t\tif (seg.trendDirection === TrendDirection.Up) allowUp.add(k); else allowDown.add(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.forEach((row, idx) => {\n\t\t\t\trow.trendUp = allowUp.has(idx) ? row.trendUp : false;\n\t\t\t\trow.trendDown = allowDown.has(idx) ? row.trendDown : false;\n\t\t\t\tif (s.trendDominatesHighlightedWindow) {\n\t\t\t\t\tif (allowUp.has(idx)) {\n\t\t\t\t\t\trow.singlePointDown = false;\n\t\t\t\t\t\trow.twoSigmaDown = false;\n\t\t\t\t\t\trow.shiftDown = false;\n\t\t\t\t\t} else if (allowDown.has(idx)) {\n\t\t\t\t\t\trow.singlePointUp = false;\n\t\t\t\t\t\trow.twoSigmaUp = false;\n\t\t\t\t\t\trow.shiftUp = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfor (const row of out) {\n\t\t\tif (row.ghost || !isNumber(row.value) || row.mean === null) continue;\n\t\t\tif (metricImprovement === ImprovementDirection.Neither) continue;\n\t\t\t// Recompute candidates from updated flags\n\t\t\tconst { aligned, opposite } = deriveOriginalCandidates(row, metricImprovement);\n\t\t\trow.specialCauseImprovementValue = aligned ? row.value! : null;\n\t\t\trow.specialCauseConcernValue = opposite ? row.value! : null;\n\t\t\t// Re-apply pruning to stabilise outcome\n\t\t\tapplySqlPruning(row, metricImprovement, s.metricConflictRule!, s.preferImprovementWhenConflict === true, s.conflictStrategy, s.ruleHierarchy, s.preferTrendWhenConflict === true);\n\t\t}\n\t}\n\n\treturn { rows: out };\n}\n\nexport default { buildSpcV26a };\n\n// Engine-owned visuals API: compute UI-agnostic visual categories with optional boundary-window upgrades\nexport function buildSpcV26aWithVisuals(\n\targs: BuildArgsV2,\n\tvisuals?: {\n\t\ttrendVisualMode?: TrendVisualMode;\n\t\tenableNeutralNoJudgement?: boolean;\n\t\tboundaryWindows?: (BoundaryWindowsOptions & { directionOverride?: ImprovementDirection });\n\t}\n): { rows: SpcRowV2[]; visuals: SpcVisualCategory[] } {\n\tconst res = buildSpcV26a(args);\n\tconst base = computeSpcVisualCategories(res.rows, {\n\t\tmetricImprovement: args.metricImprovement,\n\t\ttrendVisualMode: visuals?.trendVisualMode ?? TrendVisualMode.Ungated,\n\t\tenableNeutralNoJudgement: visuals?.enableNeutralNoJudgement ?? true,\n\t});\n\n\tconst bw = visuals?.boundaryWindows;\n\tif (!bw || bw.mode !== \"RecalcCrossing\") return { rows: res.rows, visuals: base };\n\n\tconst dir = bw.directionOverride ?? args.metricImprovement;\n\tconst win = computeBoundaryWindowCategories(res.rows, dir, bw);\n\n\t// Overlay upgrade: only promote Common/NoJudgement to Improvement/Concern as per window categories\n\tconst overlay: SpcVisualCategory[] = base.map((cat, i) => {\n\t\tconst w = win[i];\n\t\tif (cat === SpcVisualCategory.Common || cat === SpcVisualCategory.NoJudgement) {\n\t\t\tif (w === SpcVisualCategory.Improvement) return SpcVisualCategory.Improvement;\n\t\t\tif (w === SpcVisualCategory.Concern) return SpcVisualCategory.Concern;\n\t\t}\n\t\treturn cat;\n\t});\n\treturn { rows: res.rows, visuals: overlay };\n}\n\n// Intentionally not re-exporting SpcVisualCategory here; canonical path is via postprocess/visualCategories (barrel re-exports)\n","import { buildSpcV26aWithVisuals } from \"./engine\";\nimport { SpcVisualCategory, TrendVisualMode } from \"./postprocess/visualCategories\";\nimport {\n\tBuildArgsV2,\n\tImprovementDirection,\n\tSpcRowV2,\n\tMetricConflictRule,\n\tTrendSegmentationStrategy,\n\tTrendSegmentationMode,\n\ttype SpcSettingsV26a,\n} from \"./types\";\n\nexport enum VisualsScenario {\n\tNone = \"none\",\n\tRecalcCrossingShift = \"recalc-crossing-shift\",\n\tRecalcCrossingTrend = \"recalc-crossing-trend\",\n\tRecalcCrossingTwoSigma = \"recalc-crossing-two-sigma\",\n\tRecalculationsRecalculated = \"recalculations-recalculated\",\n\tBaselinesRecalculated = \"baselines-recalculated\",\n}\n\nexport function buildVisualsForScenario(\n\targs: BuildArgsV2,\n\tscenario: VisualsScenario,\n\topts?: {\n\t\ttrendVisualMode?: TrendVisualMode;\n\t\tenableNeutralNoJudgement?: boolean;\n\t}\n): { rows: SpcRowV2[]; visuals: SpcVisualCategory[] } {\n\tconst tvm = opts?.trendVisualMode ?? TrendVisualMode.Ungated;\n\tconst enn = opts?.enableNeutralNoJudgement ?? true;\n\n\t// Compute boundary indices from provided baselines first (deterministic in dataset tests)\n\tconst explicitBoundaries: number[] = Array.isArray(args.data)\n\t\t? args.data.map((d, i) => (d?.baseline ? i : -1)).filter((i) => i >= 0)\n\t\t: [];\n\n\tlet boundaryWindows: any | undefined;\n\tswitch (scenario) {\n\t\tcase VisualsScenario.RecalcCrossingShift: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 2,\n\t\t\t\tpostWindow: 4,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.RecalcCrossingTrend: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 1,\n\t\t\t\tpostWindow: 5,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.RecalcCrossingTwoSigma: {\n\t\t\t// Anchor at the baseline row (first point of the new partition)\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 1,\n\t\t\t\tpostWindow: 1,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\t}\n\t\tcase VisualsScenario.BaselinesRecalculated:\n\t\t\t// postWindow will be extended after build once we know boundary index and series length\n\t\t\tboundaryWindows = {\n\t\t\t\tmode: \"RecalcCrossing\",\n\t\t\t\tpreWindow: 0,\n\t\t\t\tpostWindow: 0,\n\t\t\t\tprePolarity: \"Same\",\n\t\t\t\tdirectionOverride: args.metricImprovement,\n\t\t\t\tboundaryIndices: explicitBoundaries,\n\t\t\t};\n\t\t\tbreak;\n\t\tcase VisualsScenario.RecalculationsRecalculated:\n\t\tcase VisualsScenario.None:\n\t\tdefault:\n\t\t\tboundaryWindows = undefined;\n\t}\n\n\tconst { rows, visuals } = buildSpcV26aWithVisuals(args, {\n\t\ttrendVisualMode: tvm,\n\t\tenableNeutralNoJudgement: enn,\n\t\tboundaryWindows,\n\t});\n\n\tlet out = visuals.slice();\n\n\t// Find first boundary index (prefer explicit baselines)\n\tlet boundaryIndex = explicitBoundaries.length ? explicitBoundaries[0]! : -1;\n\tif (boundaryIndex < 0) {\n\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\tif (rows[i].partitionId !== rows[i - 1].partitionId) {\n\t\t\t\tboundaryIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scenario-specific adjustments\n\tif (\n\t\tscenario === VisualsScenario.RecalculationsRecalculated ||\n\t\tscenario === VisualsScenario.BaselinesRecalculated\n\t) {\n\t\tif (boundaryIndex > 0) {\n\t\t\tout[boundaryIndex - 1] = SpcVisualCategory.Common;\n\t\t}\n\t}\n\t// For BaselinesRecalculated, we do not force post-baseline colours here; dataset expectations provide explicit colours.\n\n\treturn { rows, visuals: out };\n}\n\n// ---- Settings presets (engine-owned) ----\n\n// SQL v2.6 parity preset (with trend across partitions from SQL v2.2 note)\nexport const PARITY_V26: Readonly<SpcSettingsV26a> = Object.freeze({\n\tminimumPoints: 13,\n\tshiftPoints: 6,\n\ttrendPoints: 6,\n\texcludeMovingRangeOutliers: false,\n\tmetricConflictRule: MetricConflictRule.Improvement,\n\ttrendAcrossPartitions: true,\n\ttwoSigmaIncludeAboveThree: true,\n\tchartLevelEligibility: true,\n});\n\nexport function withParityV26(overrides?: SpcSettingsV26a): SpcSettingsV26a {\n\treturn { ...PARITY_V26, ...(overrides ?? {}) };\n}\n\n// Conflict-focused preset for datasets with trend/mean crossings.\n// Uses segmentation with CrossingAfterUnfavourable and keeps other parity defaults.\nexport function withConflictPresetV26(\n\toverrides?: SpcSettingsV26a\n): SpcSettingsV26a {\n\treturn withParityV26({\n\t\ttrendSegmentationMode: TrendSegmentationMode.AutoWhenConflict,\n\t\ttrendSegmentationStrategy:\n\t\t\tTrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\t// Keep strict SQL pruning semantics by default; allow caller to opt into stronger levers below\n\t\tpreferTrendWhenConflict: false,\n\t\ttrendDominatesHighlightedWindow: false,\n\t\t...(overrides ?? {}),\n\t});\n}\n\n// Direction-aware conflict preset that auto-chooses the safest behaviour per improvement direction:\n//  - Up (\"High is good\"): prefer improvement override and implicitly disable segmentation via engine gating\n//  - Down (\"Low is good\"): keep segmentation enabled with CrossingAfterUnfavourable (works for dataset parity)\n//  - Neither: fall back to generic conflict preset defaults\n// Overrides are applied last so callers (e.g. Storybook controls) can still force a specific behaviour.\nexport function withConflictPresetAutoV26(\n\tmetricImprovement: ImprovementDirection,\n\toverrides?: SpcSettingsV26a\n): SpcSettingsV26a {\n\tswitch (metricImprovement) {\n\t\tcase ImprovementDirection.Up:\n\t\t\treturn withConflictPresetV26({\n\t\t\t\t// Engine will gate segmentation off when this is true\n\t\t\t\tpreferImprovementWhenConflict: true,\n\t\t\t\ttrendSegmentationMode: TrendSegmentationMode.Off,\n\t\t\t\t...(overrides ?? {}),\n\t\t\t});\n\t\tcase ImprovementDirection.Down:\n\t\t\treturn withConflictPresetV26({\n\t\t\t\t// Keep segmentation to resolve cross-mean runs for low-is-good datasets\n\t\t\t\tpreferImprovementWhenConflict: false,\n\t\t\t\ttrendSegmentationMode: TrendSegmentationMode.AutoWhenConflict,\n\t\t\t\ttrendSegmentationStrategy:\n\t\t\t\t\tTrendSegmentationStrategy.CrossingAfterUnfavourable,\n\t\t\t\t...(overrides ?? {}),\n\t\t\t});\n\t\tdefault:\n\t\t\treturn withConflictPresetV26({ ...(overrides ?? {}) });\n\t}\n}\n// Named exports only; no default export to avoid collisions\n"],"names":["RULE_RANK_BY_ID","SpcRuleId","MR_UCL_FACTOR","XMR_THREE_SIGMA_FACTOR","T_TRANSFORM_EXP","isNumber","n","mean","nums","a","b","movingRanges","values","ghosts","mr","lastIdx","i","v","prev","mrMeanWithOptionalExclusion","excludeOutliers","vals","arr","meanMr","ucl","mrMean","xmrLimits","center","threeSigma","twoSigma","oneSigma","computePartitionLimits","chartType","excludeMovingRangeOutliers","ChartType","yVals","mrStats","eligible","centerY","limY","inv","y","upl","lpl","u2","l2","u1","l1","m","p","qgeom","q","k","qLower3","qUpper3","qLower2","qUpper2","qLower1","qUpper1","mrVals","rawMrMean","rawMrUcl","eligibleVals","acc","mri","tmp","lim","detectRulesInPartition","rows","cfg","idxs","_","get","shiftN","trendN","runHigh","runLow","r","j","w","trip","allHigh","allLow","u3","l3","highs","lows","quint","win","seq","inc","dec","getDirectionalSummary","row","up","dn","upMax","dnMax","primeDirection","PrimeDirection","deriveOriginalCandidates","metric","aligned","ImprovementDirection","opposite","applySqlPruning","metricConflictRule","preferImprovementWhenConflict","conflictStrategy","ruleHierarchy","preferTrendWhenConflict","originalImprovement","originalConcern","resolveConflict","VariationIcon","winningSide","Side","winningRank","winner","args","upTrend","downTrend","strategy","ConflictStrategy","order","rid","upHas","dnHas","MetricConflictRule","TrendDirection","signOf","x","sideFor","delta","s","computeTrendSegments","runs","startSegment","initialSide","value","extendSegment","deltaAbs","minV","maxV","maxAbsDelta","flushSegment","segments","segStart","endIdx","segSide","dir","start","rr","end","side","updated","favourableSide","impr","oppositeSide","chooseSegmentsForHighlight","opts","TrendSegmentationStrategy","fav","unfav","highlight","run","all","best","segs","chosen","idx","favSegs","unSegs","seg","SpcVisualCategory","TrendVisualMode","sideFlags","upAny","downAny","computeSpcVisualCategories","metricImprovement","trendVisualMode","enableNeutral","computeBoundaryWindowCategories","options","mode","out","preWin","postWin","prePolarity","setIfUpgrade","cat","cur","partitionFallbackMean","pid","boundaries","boundary","prevStart","curEnd","oldMean","newMean","favourable","postCat","preCat","normaliseSpcSettingsV2","input","h","t","buildSpcV26a","data","settings","TrendSegmentationMode","resolvedMode","canon","d","partitions","segmentationEnabled","totalEligiblePoints","chartEligible","partitionId","part","withLines","pointRank","eligibleHere","hasConflict","highlights","allowUp","allowDown","highSide","lowSide","buildSpcV26aWithVisuals","visuals","res","base","bw","overlay","VisualsScenario","buildVisualsForScenario","scenario","tvm","enn","explicitBoundaries","boundaryWindows","boundaryIndex","PARITY_V26","withParityV26","overrides"],"mappings":"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"}